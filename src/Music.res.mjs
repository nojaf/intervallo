// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Ring from "./Ring.res.mjs";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";

let majorScalePattern = [
  "WholeStep",
  "WholeStep",
  "HalfStep",
  "WholeStep",
  "WholeStep",
  "WholeStep",
  "HalfStep"
];

let minorScalePattern = [
  "WholeStep",
  "HalfStep",
  "WholeStep",
  "WholeStep",
  "HalfStep",
  "WholeStep",
  "WholeStep"
];

function urlEncodeScalePattern(pattern) {
  if (Primitive_object.equal(pattern, majorScalePattern)) {
    return "major";
  } else if (Primitive_object.equal(pattern, minorScalePattern)) {
    return "minor";
  } else {
    return "custom";
  }
}

function urlDecodeScalePattern(pattern) {
  if (pattern === "minor") {
    return minorScalePattern;
  } else {
    return majorScalePattern;
  }
}

function displayNote(note) {
  switch (note) {
    case "C" :
      return "C";
    case "CSharp" :
      return "C#";
    case "D" :
      return "D";
    case "DSharp" :
      return "D#";
    case "E" :
      return "E";
    case "F" :
      return "F";
    case "FSharp" :
      return "F#";
    case "G" :
      return "G";
    case "GSharp" :
      return "G#";
    case "A" :
      return "A";
    case "ASharp" :
      return "A#";
    case "B" :
      return "B";
  }
}

function urlEncodeNote(note) {
  switch (note) {
    case "C" :
      return "c";
    case "CSharp" :
      return "csharp";
    case "D" :
      return "d";
    case "DSharp" :
      return "dsharp";
    case "E" :
      return "e";
    case "F" :
      return "f";
    case "FSharp" :
      return "fsharp";
    case "G" :
      return "g";
    case "GSharp" :
      return "gsharp";
    case "A" :
      return "a";
    case "ASharp" :
      return "asharp";
    case "B" :
      return "b";
  }
}

function urlDecodeNote(note) {
  switch (note) {
    case "a" :
      return "A";
    case "asharp" :
      return "ASharp";
    case "b" :
      return "B";
    case "csharp" :
      return "CSharp";
    case "d" :
      return "D";
    case "dsharp" :
      return "DSharp";
    case "e" :
      return "E";
    case "f" :
      return "F";
    case "fsharp" :
      return "FSharp";
    case "g" :
      return "G";
    case "gsharp" :
      return "GSharp";
    default:
      return "C";
  }
}

let noteElement = displayNote;

function chordName(chord) {
  let root = displayNote(chord.root);
  let match = chord.quality;
  switch (match) {
    case "Major" :
      return root + "M";
    case "Minor" :
      return root + "m";
    case "Diminished" :
      return root + "dim";
  }
}

let chromaticRing = Ring.make([
  "C",
  "CSharp",
  "D",
  "DSharp",
  "E",
  "F",
  "FSharp",
  "G",
  "GSharp",
  "A",
  "ASharp",
  "B"
]);

let allNotes = new Set(chromaticRing.items);

function semitonesBetween(from, to) {
  return Ring.distanceBetween(chromaticRing, from, to);
}

function make(intervals, rootNote) {
  let rootIdx = Ring.indexOf(chromaticRing, rootNote);
  let match = Stdlib_Array.reduce(intervals, [
    [],
    rootIdx
  ], (param, interval) => {
    let currentIdx = param[1];
    let note = Ring.at(chromaticRing, currentIdx);
    let distanceToNextNote = interval === "WholeStep" ? 2 : 1;
    return [
      Belt_Array.concatMany([
        param[0],
        [note]
      ]),
      currentIdx + distanceToNextNote | 0
    ];
  });
  return {
    rootNote: rootNote,
    intervals: intervals,
    notes: Ring.make(match[0])
  };
}

function chordAtIndex(scale, degree) {
  let root = Ring.at(scale.notes, degree);
  let third = Ring.at(scale.notes, degree + 2 | 0);
  let fifth = Ring.at(scale.notes, degree + 4 | 0);
  let rootToThird = Ring.distanceBetween(chromaticRing, root, third);
  let thirdToFifth = Ring.distanceBetween(chromaticRing, third, fifth);
  let quality = rootToThird === 4 ? "Major" : (
      rootToThird === 3 && thirdToFifth === 3 ? "Diminished" : "Minor"
    );
  return {
    root: root,
    third: third,
    fifth: fifth,
    quality: quality
  };
}

function chordForNote(scale, note) {
  if (!Ring.contains(scale.notes, note)) {
    throw "Note not in scale";
    throw undefined;
  }
  let degree = Ring.indexOf(scale.notes, note);
  return chordAtIndex(scale, degree);
}

let Scale = {
  make: make,
  chordAtIndex: chordAtIndex,
  chordForNote: chordForNote
};

export {
  majorScalePattern,
  minorScalePattern,
  urlEncodeScalePattern,
  urlDecodeScalePattern,
  displayNote,
  urlEncodeNote,
  urlDecodeNote,
  noteElement,
  chordName,
  chromaticRing,
  allNotes,
  semitonesBetween,
  Scale,
}
/* chromaticRing Not a pure module */
